# Fix three issues: 1Password trigger, input column width, API key persistence

**Date:** 2026-02-18 15:19
**Task:** Fix three user-reported issues

## Goal
1. Stop 1Password from prompting to save login on every click
2. Narrow the Input column in the results table (30% less wide)
3. Fix API key disappearing from localStorage

## Approach

### 1. 1Password trigger
The API key input has `type="password"` which triggers password managers. Fix by:
- Adding `autoComplete="off"` and `data-1p-ignore` attribute to the API key input
- Wrapping in a `<div>` instead of `<form>` (already the case, so just need the attributes)

### 2. Input column too wide
The results table Input column has `style={{ width: '140px' }}` but on desktop it's expanding. Need to constrain it more:
- Change from `width: 140px` to `width: 160px; max-width: 160px` to prevent expansion
- The `minWidth: 300px` on result columns is fine

### 3. API key persistence
Looking at the code: `cacheSaveStr('apiKey', apiKey)` only saves when `apiKey` is truthy. The load effect runs on mount and restores it. The issue is likely that the "first run" skip guard only saves when apiKey changes after mount — but if Clerk auth causes a re-mount or if the component unmounts/remounts during sign-in, the first-run ref resets and the empty string overwrites the saved key.

Fix: Don't skip first run for apiKey save — instead, only save when apiKey is non-empty (which is already checked). Actually the bug is: on mount, savedKey loads → setApiKey(savedKey). Then the effect fires with the new apiKey value, but `apiKeyFirstRun` is true so it skips. On re-render from auth change, the component re-mounts, apiKey starts as '' (initial useState), the first-run ref is true so it skips — but then the load effect runs and restores it. This should work...

Actually the real issue: if the component re-mounts (e.g. auth state change), useState('') initializes apiKey to '', then the useEffect load fires and sets it. But between those two, React may trigger the save effect with '' — and since firstRun is true, it skips. Then when the load effect sets the real key, the save effect fires again (firstRun is now false) and saves correctly. So this should work.

Wait — let me look more carefully. The `PromptTesterPage` component conditionally renders `<PromptTester />` only when signed in. If auth state flickers, PromptTester unmounts and remounts, resetting all state including apiKey to ''. On remount, the load effect restores it. But the save effect for apiKey has `apiKeyFirstRun` ref — on remount, firstRun is true, so the empty '' write is skipped, then the loaded value triggers a save. This seems OK.

The more likely issue: `if (apiKey) cacheSaveStr(...)` — this means if apiKey is ever set to '' (e.g. user clears the field), the old value stays in localStorage. But if something else clears localStorage (like a deploy changing the domain/port), the key is lost. The user mentions "every deploy" — Railway deploys go to a different URL each time? No, custom domain stays same. But port changes during dev would be different origins → different localStorage.

Most likely fix: The real issue might be simpler — the condition `if (apiKey)` means an empty string never clears the cache, which is fine. But the `apiKeyFirstRun` skip means if the component re-mounts quickly (auth flicker), the empty initial state might race. Let me make the save more robust: always save (even empty), and remove the firstRun guard — instead, only save after the load effect has run.

Simpler fix: Use a `loaded` ref that's set to true after the cache load effect runs. Only save when loaded is true.

## Files to Modify
- `apps/web/src/app/page.tsx` — all three fixes
